/**
 *  @file lagoon/lagoon.hpp
 *  @brief The all-in-one inclusion of the whole Lagoon library
 *
 *  @author Matus Chochlik
 *
 *  Copyright 2008-2010 Matus Chochlik. Distributed under the Boost
 *  Software License, Version 1.0. (See accompanying file
 *  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 */

#ifndef LAGOON_LAGOON_1011291729_HPP
#define LAGOON_LAGOON_1011291729_HPP

#include <lagoon/lagoon_fwd.hpp>
#include <lagoon/interfaces.hpp>
#include <lagoon/meta_objects.hpp>
#include <lagoon/reflection.hpp>
//TODO: move this somewhere else
#include <lagoon/auxiliary/polymorph_factory.hpp>

/** @mainpage Mirror C++ reflection library - Lagoon run-time layer
 *
 *  @image html  lagoon.png
 *  @image latex lagoon.png
 *
 *  Copyright &copy; 2006-2011 Matus Chochlik.
 *
 *  Distributed under the Boost Software License, Version 1.0.
 *  (See accompanying file LICENSE_1_0.txt or copy at
 *  http://www.boost.org/LICENSE_1_0.txt)
 *
 *  This is a reference manual generated by @em Doxygen, for the Lagoon
 *  run-time layer, which is part of the Mirror reflection library.
 *
 *  Other resources and documentation for Mirror and the related libraries and utilities
 *  can also be found on the project <A HREF="../../../index.html">home page</A>.
 *
 *  Lagoon is a run-time layer which is built on top of the compile-time
 *  meta-objects implemented by Mirror and provides a polymorphic interface
 *  for these meta-objects. This means that once a base-level object
 *  (namespace, class, class member, etc.) is registered with Mirror it is
 *  also reflectible by Lagoon.
 *
 *  While the compile-time facilities implemented by Mirror provide
 *  meta-data usable in meta-programs which can generate efficient program
 *  code, the nature of this meta-data is inherently static. There are however
 *  situations, where one needs to use the meta-data in a dynamic manner
 *  dependent on other data available only at run-time.
 *  One might for example want to traverse the set of class' member variables
 *  and find the one searched for by the user or satisfying a predicate based
 *  on run-time input. While this can be achieved even with the static
 *  meta-objects provided by Mirror (as proved by the fact that the Lagoon
 *  layer is built on top of them), the compile-time interface makes it
 *  difficult and is not very suitable for such tasks.
 *
 *  Thus the interfaces and their implementations defined by the Lagoon
 *  layer provide basically the same meta-data as Mirror does. The difference
 *  is, that everywhere Mirror requires doing a traversal of meta-objects
 *  by a compile-time generic algorithm, Lagoon allows to traverse them in
 *  a run-time loop. Furthermore the interfaces which Lagoon defines
 *  for the Mirror's concepts use run-time polymorphism (i.e. virtual functions)
 *  with all its virtues (and drawbacks).
 *  This means that the different meta-objects reflecting different base-level
 *  objects can be accessed via a single interface type.
 *  The main drawback is the performance penalty induced by virtual function
 *  calls and the inability of the compiler to inline such calls in many cases.
 *
 *  The decision whether to use Mirror or Lagoon should therefore be based
 *  on application-specific factors (as performance, source code size,
 *  simplicity of application code, tasks performed by the applications, etc.).
 */

/// The Lagoon run-time layer built on Mirror is defined in this namespace
/** The Lagoon is a run-time layer which is built on top of the compile-time
 *  meta-objects provided by Mirror.
 */
#ifdef MIRROR_DOCUMENTATION_ONLY
namespace lagoon
{
#else
LAGOON_NAMESPACE_BEGIN
#endif

#ifdef MIRROR_DOCUMENTATION_ONLY
}
/* namespace lagoon */
#else
LAGOON_NAMESPACE_END
#endif

#endif //include guard

